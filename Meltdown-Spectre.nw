\documentclass[a4paper]{scrbook}

\usepackage{noweb}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[acronym,toc,numberedsection=autolabel,nopostdot]{glossaries}
%\usepackage[acronym,toc]{glossaries}

\renewcommand{\autodot}{}

\hypersetup{
    colorlinks=true,
    linkcolor=[rgb]{0,0,.4},
    urlcolor=[rgb]{.3,0,.4},
    linktoc=all,
    pdftitle={Meltdown and Spectre Samples},
    bookmarks=true,
}

\makeglossaries

\setacronymstyle{long-short}

\newacronym{rng}{RNG}{random number generator}

\begin{document}

\author{U. Plonus}
\title{Meltdown and Spectre Samples}
\subtitle{Written in Assembly}
\maketitle

\tableofcontents

\chapter{Introduction}

\section{Overview}

TBD

\section{Nasm}

TBD

<<preamble>>=
bits 64
     global         _start
     pagesize       equ  4096
@

\chapter{Cache Access Timing}

\section{Introduction}

TBD

\section{Detect Cache Access Time}

TBD

<<tsc-64bit>>=
     rdtsc
     shl       RDX,32
     add       RAX,RDX
@

TBD

<<calculate-cache-access-time>>=
_calccachetime:
     xor       RAX,RAX
     xor       RDX,RDX
     lfence
<<tsc-64bit>>
     mov       R8,RAX
     mov       RCX,[RDI]
     lfence
<<tsc-64bit>>
     sub       RAX,R8
     ret
@

\section{Detect Cache Access Time}

TBD

<<cachetiming.asm>>=
<<preamble>>

<<cachetiming-rodata>>

<<cachetiming-uninitialized-data>>

section .text
_start:
     mov       RDI,suncached
     call      _print
<<exitProgram>>

<<calculate-cache-access-time>>

<<xorshift-prng>>

<<utilities>>
@

TBD

<<cachetiming-uninitialized-data>>=
section .bss
     measures:      resq 2048
     align pagesize
     data:          times 2 resb pagesize
@

TBD

<<cachetiming-rodata>>=
section .rodata
     suncached:     db "Uncached Access Time: ",0x00
@

\section{Read Array via Cache Access Time}

TBD

\chapter{Signals}

\section{Basics}

TBD

\section{Detecting Signals}

TBD

\section{Handling Signals}

TBD

\chapter{Utilities}

\section{Introduction}

TBD

<<utilities>>=
<<print>>
@

\section{Exit Program}

TBD

<<exitProgram>>=
     xor       RDI,RDI
     mov       RAX,60
     syscall
@

\section{Random Number Generator}

To initialize the data a \gls{rng} is used. The sample programs use
xorshift\footnote{\url{https://en.wikipedia.org/wiki/Xorshift}} as \gls{rng}.

The start of the memory area to fill with random numbers is given in [[RDI]] and
the number of bytes to fill in [[RSI]]. [[RSI]] must be a multiple of $4$. The
seed of the \gls{rng} is given in [[EDX]].

First we move the number of values to be generated to [[RCX]] (which is a
counter in x86 processors) and divide it by 4 (because we use a 32bit
\gls{rng}).

<<xorshift-prng>>=
_xorshift:
     mov       RCX,RSI
     shr       RCX,2
@

Now we can generate the next 32bit random number.

<<xorshift-prng>>=
     mov       EAX,EDX
.next_random:
     mov       EBX,EAX
     shl       EAX,13
     xor       EAX,EBX
     mov       EBX,EAX
     shr       EAX,17
     xor       EAX,EBX
     mov       EBX,EAX
     shl       EAX,5
     xor       EAX,EBX
@

Because we want to use multiple random numbers we store the value of [[EAX]] to
[[[RDI]]] and loop for the next random number.

<<xorshift-prng>>=
     stosd
     loop      .next_random
     ret
@

\section{Printing Text}

The routine [[_print]] prints a null-terminated string to the terminal (stdout).
The only argument passed in to the routine (in [[RDI]]) is the address of the
string to print.

So first we start with clearing [[AL]] (setting it to null) and saving the
address of the string to [[RSI]]. We're using [[RSI]] because we later need the
address to calculate the length of the string and also [[RSI]] is the register
that we need to use for the string address in the systemcall.

<<print>>=
_print:
     xor       AL,AL
     mov       RSI,RDI
@

Next we search for the terminating [[null]] ('[[\0]]') character. For this we
use the instruction [[scasb]] (scan string byte) which compares the byte at the
address [[[RDI]]] with the value in [[AL]] and sets the flags accordingly. When
the byte at [[[RDI]]] is not the value of [[AL]] the the next instruction
([[jne]]) jumps to the given label ([[.next_char]] in this case).

[[scasb]] additionally increments [[RDI]] so that we go through the string until
[[\0]] is found.

<<print>>=
.next_char:
     scasb
     jne       .next_char
@

After we have found the string termination we calculate the number of bytes that
the string has. For this we copy the value of the last byte read (which is in
[[RDI]]) to [[RDX]] and subtract the start of the string (which we saved to
[[RSI]]).

Now we have the address of the string in [[RSI]] and the length of the string in
[[RDX]] which are the 2nd and 3rd argument in a systemcall. The 1st argument (in
[[RDI]]) to the systemcall is the file descriptor ([[1]] is stdout).
Additionally the number of the systemcall ([[1]]) is passed in [[RAX]]. The
systemcall ([[syscall]]) now prints [[RDX]] bytes from [[[RSI]]] to the file
descriptor [[RDI]].

<<print>>=
     mov       RDX,RDI
     sub       RDX,RSI
     mov       RAX,1
     mov       RDI,1
     syscall
@

Now that we are done and can return to the caller.

<<print>>=
     ret
@

\section{Printing Numbers}

TBD

\appendix

\printacronyms

\chapter{Code Chunks}

\nowebchunks

\end{document}
