\documentclass[paper=a4]{scrbook}

\renewcommand{\rm}[0]{\normalfont \rmfamily}
\renewcommand{\tt}[0]{\normalfont \ttfamily}
\renewcommand{\it}[0]{\normalfont \itshape}

\usepackage{noweb}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage[acronym,toc,numberedsection=autolabel,nopostdot]{glossaries}

\renewcommand{\autodot}{}

\hypersetup{
    colorlinks=true,
    linkcolor=[rgb]{0,0,.4},
    urlcolor=[rgb]{.3,0,.4},
    linktoc=all,
    pdftitle={Meltdown and Spectre Samples},
}

\makeglossaries

\setacronymstyle{long-short}

\newacronym{rng}{RNG}{random number generator}
\newglossaryentry{x86}{
    name={x86},
    description={x86 denotes a microprocessor architecture based on the
    8086/8088}
}

\begin{document}

\author{U. Plonus}
\title{Meltdown and Spectre Samples}
\subtitle{Written in Assembly}
\maketitle

\tableofcontents

\chapter{Introduction}

\section{Overview}

TBD

\section{Nasm}

TBD

<<preamble>>=
bits 64
     global         _start
     pagesize       equ  4096
@

\chapter{Cache Access Timing}

\section{Introduction}

TBD

\section{Detect Cache Access Time}

TBD

<<tsc-64bit>>=
     rdtsc
     shl       RDX,32
     add       RAX,RDX
@

TBD

<<calculate-cache-access-time>>=
_calccachetime:
     xor       RAX,RAX
     xor       RDX,RDX
     lfence
<<tsc-64bit>>
     mov       R8,RAX
     mov       RCX,[RDI]
     lfence
<<tsc-64bit>>
     sub       RAX,R8
     ret
@

\section{Detect Cache Access Time}

TBD

<<cachetiming.asm>>=
<<preamble>>

<<cachetiming-rodata>>

<<cachetiming-uninitialized-data>>

section .text
_start:
     mov       RDI,suncached
     call      _print
<<exitProgram>>

<<calculate-cache-access-time>>

<<xorshift-prng>>

<<utilities>>
@

TBD

<<cachetiming-uninitialized-data>>=
section .bss
     align          pagesize
     data:          times 2 resb pagesize
@

TBD

<<cachetiming-rodata>>=
section .rodata
     suncached:     db "Uncached Access Time: ",0x00
     scached:       db "Cached Access Time: ",0x00
@

\section{Read Array via Cache Access Time}

TBD

\chapter{Signals}

\section{Basics}

TBD

\section{Detecting Signals}

TBD

\section{Handling Signals}

TBD

\chapter{Utilities}

\section{Introduction}

TBD

<<utilities>>=

<<nprint>>

<<print>>
@

\section{Exit Program}

TBD

<<exitProgram>>=
     xor       RDI,RDI
     mov       RAX,60
     syscall
@

\section{Random Number Generator}

To initialize the data a \gls{rng} is used. The sample programs use
xorshift\footnote{\url{https://en.wikipedia.org/wiki/Xorshift}} as \gls{rng}.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address of the memory which is to be filled with random numbers
\item [RSI] the number of bytes that are filled with random numbers. This must
be a multiple of $4$
\item [EDX] the seed of the \gls{rng}
\end{labeling}

First we move the number of values to be generated to [[RCX]] (which is a
counter in \gls{x86} processors) and divide it by 4 (because we use a 32bit
\gls{rng}). Additionally we move the seed to [[EAX]].

<<xorshift-prng>>=
_xorshift:
     mov       RCX,RSI
     shr       RCX,2
     mov       EAX,EDX
@

Now we can generate the next 32bit random number.

<<xorshift-prng>>=
.next_random:
     mov       EBX,EAX
     shl       EAX,13
     xor       EAX,EBX
     mov       EBX,EAX
     shr       EAX,17
     xor       EAX,EBX
     mov       EBX,EAX
     shl       EAX,5
     xor       EAX,EBX
@

Because we want to generate multiple random numbers we store the value of
[[EAX]] to [[[RDI]]] and loop for the next random number.

<<xorshift-prng>>=
     stosd
     loop      .next_random
     ret
@

\section{Printing Strings}

\subsection{Printing Strings with Length}

The routine [[_nprint]] prints a string with the given length to [[stdout]].

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the number of bytes to print to [[stdout]]
\item [RSI] the address to the bytes to print to [[stdout]]
\end{labeling}

We move the number of bytes to print to [[RDX]] which is the 3rd parameter to
the systemcall. Next we move the address of the bytes to print to [[RSI]] which
is the 2nd parameter to the systemcall. The 1st argument (in [[RDI]]) to the
systemcall is the file descriptor ([[1]] is stdout). Additionally the number of
the systemcall ([[1]]) is passed in [[RAX]]. The systemcall ([[syscall]]) now
prints [[RDX]] bytes from [[[RSI]]] to the file descriptor [[RDI]].

At the end we return to the caller.

<<nprint>>=
_nprint:
     mov       RDX,RSI
     mov       RSI,RDI
     mov       RDI,1
     mov       RAX,1
     syscall
     ret
@

\subsection{Printing C-Strings}

The routine [[_print]] prints a null-terminated string to [[stdout]].

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address to the null-terminated bytes to print to [[stdout]]
\end{labeling}

So first we start with clearing [[AL]] (setting it to null) and saving the
address of the string to [[RSI]]. We're using [[RSI]] because we later need the
address to calculate the length of the string.

<<print>>=
_print:
     xor       AL,AL
     mov       RSI,RDI
@

Next we search for the terminating [[null]] ('[[\0]]') character. For this we
use the instruction [[scasb]] (scan string byte) which compares the byte at the
address [[[RDI]]] with the value in [[AL]] and sets the flags accordingly. When
the byte at [[[RDI]]] is not the value of [[AL]] the the next instruction
([[jne]]) jumps to the given label ([[.next_char]] in this case).

[[scasb]] additionally increments [[RDI]] so that we go through the string until
[[\0]] is found.

<<print>>=
.next_char:
     scasb
     jne       .next_char
@

After we have found the string termination we calculate the number of bytes that
the string has. For this we exchange the registers [[RDI]] and [[RSI]]. In
[[RDI]] we now have the starting address of the bytes to print and in RSI we
have the end address of the bytes to print. After that we calculate the number
of bytes to print.

<<print>>=
     xchg      RDI,RSI
     sub       RSI,RDI
@

TODO
Now we have the address of the string in [[RSI]] and the length of the string in
[[RDX]] which are the 2nd and 3rd argument in a systemcall. The 1st argument (in
[[RDI]]) to the systemcall is the file descriptor ([[1]] is stdout).
Additionally the number of the systemcall ([[1]]) is passed in [[RAX]]. The
systemcall ([[syscall]]) now prints [[RDX]] bytes from [[[RSI]]] to the file
descriptor [[RDI]].

<<print>>=
     call      _nprint
     ret
@

\section{Printing Numbers}

TBD

\appendix

\printglossary

\printacronyms

\chapter{Code Chunks}

\nowebchunks

\end{document}
