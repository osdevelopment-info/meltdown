\documentclass[paper=a4]{scrbook}

\renewcommand{\rm}[0]{\normalfont \rmfamily}
\renewcommand{\tt}[0]{\normalfont \ttfamily}
\renewcommand{\it}[0]{\normalfont \itshape}

\usepackage{noweb}
\usepackage{xcolor}
\usepackage[breaklinks]{hyperref}
\usepackage[acronym,toc,numberedsection=autolabel,nopostdot]{glossaries}

\renewcommand{\autodot}{}

\hypersetup{
    colorlinks=true,
    linkcolor=[rgb]{0,0,.4},
    urlcolor=[rgb]{.3,0,.4},
    linktoc=all,
    pdftitle={Meltdown and Spectre Samples},
}

\setkomafont{labelinglabel}{\ttfamily}

\newglossary*{ins}{x86-Instructions}

\makeglossaries

\setacronymstyle{long-short}

\newacronym{rng}{RNG}{random number generator}

\newglossaryentry{x86}{
    name=x86,
    description={x86 denotes a microprocessor architecture based on the
    8086/8088}
}

\newglossaryentry{rdtsc}{
    type=ins,
    name=\ttfamily{rdtsc},
    description={Read Time Stamp Counter, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}}
}

\newglossaryentry{lfence}{
    type=ins,
    name=\ttfamily{lfence},
    description={Load Fence, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}~4}
}

\newglossaryentry{clflush}{
    type=ins,
    name=\ttfamily{clflush},
    description={Flush Cache Line, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}~4}
}

\begin{document}
@

\author{U. Plonus}
\title{Meltdown and Spectre Samples}
\subtitle{Written in Assembly}
\maketitle

\tableofcontents

\chapter{Introduction}

\section{Overview}

TBD

\section{Nasm}

TBD

<<preamble>>=
bits 64
     global         _start
     pagesize       equ  4096
@ %def pagesize _start

\chapter{Cache Access Timing}

\section{Introduction}

TBD

\section{Detect Cache Access Time}

\subsection{High Resolution Timer}

First we need a high resolution timer to determine the cache access time. For
this we use the time stamp counter. The time stamp counter is monotonically
incrementing. When reading the time stamp counter (with \gls{rdtsc}) the result
is delivered back in the registers \verb|EDX| and \verb|EAX| forming a 64bit
value. The time stamp counter is not an absolute value but a relative value,
meaning that you cannot (easily) calculate from the time stamp counter to some
time units (e.g. ns). But this is no problem as we only want to measure relative
times.

To retrieve a 64bit value for the time we shift the value in \verb|EDX| 32 bits
to the left and add the value of \verb|EAX| to this.

<<tsc-64bit>>=
     rdtsc
     shl       RDX,32
     add       RAX,RDX
@

\subsection{Cache Access Time Routine}

Next we need a routine that calculates the cache access time for us.

First we have to ensure in this routine that the speculative execution of the
processor does not interfere with our time measurement. For this we use the
instruction \gls{lfence} which ensures that all previous reads are done before
executing the next instructions.

Next we access a memory location with the address \verb|RDI| by loading this
into \verb|RCX| and measure the time before and after the access.

The command \gls{lfence} before reading the time stamp counter is needed
because we have to ensure that all reads before the time measurements are done.

At last we calculate the relative time needed to access the memory location. In
theory we should see a difference whether the memory location is accessed before
or not.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address of the memory which is loaded either from the cache or
from memory
\end{labeling}

<<calculate-cache-access-time>>=
_calccachetime:
     lfence
<<tsc-64bit>>
     mov       R8,RAX
     mov       RCX,[RDI]
     lfence
<<tsc-64bit>>
     sub       RAX,R8
     ret
@ %def _calccachetime

\section{Measure Cache Access Time}

\subsection{Setup}

To measure the cache timing we create a standalone program that shows us the
time for a cached and for an uncached memory access.

First we need some area in memory with data which we can later read from. This
data area goes into the area \verb|.bss| which contains uninitialized data. We
align the data at a page boundary and reserve 2 pages for our data.

<<cachetiming-uninitialized-data>>=
section .bss
     align          pagesize
     data:          times 2 resb pagesize
@ %def data

The program begins with the label \verb|_start| and is in the section
\verb|.text|.

<<cachetiming-program>>=
section .text
_start:
@

Now we start with initialising the [[data]] area with some random data. For this
we load \verb|RDI| with the address of the [[data]] area.

<<cachetiming-program>>=
     mov       RDI,data
@

Next we load the number of bytes to fill into \verb|RSI|. For this we load the
[[pagesize]] into \verb|RSI| and multiply it with $2$ by shifting the value
1~bit to the left.

<<cachetiming-program>>=
     mov       RSI,pagesize
     shl       RSI,1
@

At last we load \verb|EDX| with some random seed. For this we use \gls{rdtsc}
and only use the lower 32~bit of the value.

<<cachetiming-program>>=
     rdtsc
     mov       EDX,EAX
@

Now we call [[_xorshift]] to fill the [[data]] area.

<<cachetiming-program>>=
     call      _xorshift
@

\subsection{Measure Time}

Now that we have setup our [[data]] area we can now cache data from the first
page by loading it into a register which also loads this into the cache.

For this we load \verb|RDI| with the address of the [[data]] area.

<<cachetiming-program>>=
     mov       RDI,data
@

Before we load the data into a register now we will clear the cache lines with
the given address. For this we use the instruction \gls{clflush}. After that
we will load the data into a register.

<<cachetiming-program>>=
     clflush   [RDI]
     mov       RCX,[RDI]
@

Now we can determine the time that is needed to load this data once again. We do
not need to load \verb|RDI| again because it has not changed.

<<cachetiming-program>>=
     call      _calccachetime
@

Now we have the relative cache access time in register \verb|RAX|. Now we can
print the measured time to \verb|stdout|.

TBD

<<cachetiming.asm>>=
<<preamble>>

<<cachetiming-rodata>>

<<cachetiming-uninitialized-data>>

<<cachetiming-program>>
@

<<cachetiming-program>>=
     mov       RDI,scached
     call      _print
     mov       RDI,scr
     mov       RSI,1
     call      _nprint
     mov       RDI,suncached
     call      _print
     mov       RDI,scr
     mov       RSI,1
     call      _nprint
<<exitProgram>>

<<calculate-cache-access-time>>

<<xorshift-prng>>

<<utilities>>
@

TBD

<<cachetiming-rodata>>=
section .rodata
     suncached:     db "Uncached Access Time: ",0x00
     scached:       db "Cached Access Time: ",0x00
     scr:           db 0x0a
@ %def suncached scached scr

\section{Read Array via Cache Access Time}

TBD

\chapter{Signals}

\section{Basics}

TBD

\section{Detecting Signals}

TBD

\section{Handling Signals}

TBD

\chapter{Utilities}

\section{Introduction}

TBD

<<utilities>>=

<<nprint>>

<<print>>
@

\section{Exit Program}

TBD

<<exitProgram>>=
     xor       RDI,RDI
     mov       RAX,60
     syscall
@

\section{Random Number Generator}

To initialize the data a \gls{rng} is used. The sample programs use
xorshift\footnote{\url{https://en.wikipedia.org/wiki/Xorshift}} as \gls{rng}.

First we clear the direction flag to ensure that we are incrementing the data
pointer \verb|RDI|.

Next we move the number of values to be generated to \verb|RCX| (which is a
counter in \gls{x86} processors) and divide it by 4 (because we use a 32bit
\gls{rng}). Additionally we move the seed to \verb|EAX|.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address of the memory which is to be filled with random numbers
\item [RSI] the number of bytes that are filled with random numbers. This must
be a multiple of $4$
\item [EDX] the seed of the \gls{rng}
\end{labeling}

<<xorshift-prng>>=
_xorshift:
     cld
     mov       RCX,RSI
     shr       RCX,2
     mov       EAX,EDX
@ %def _xorshift

Now we can generate the next 32bit random number.

<<xorshift-prng>>=
.next_random:
     mov       EBX,EAX
     shl       EAX,13
     xor       EAX,EBX
     mov       EBX,EAX
     shr       EAX,17
     xor       EAX,EBX
     mov       EBX,EAX
     shl       EAX,5
     xor       EAX,EBX
@

Because we want to generate multiple random numbers we store the value of
\verb|EAX| to \verb|[RDI]| and loop for the next random number.

<<xorshift-prng>>=
     stosd
     loop      .next_random
     ret
@

\section{Printing Strings}

\subsection{Printing Strings with Length}

The routine [[_nprint]] prints a string with the given length to \verb|stdout|.

We move the number of bytes to print to \verb|RDX| which is the 3rd parameter to
the systemcall. Next we move the address of the bytes to print to \verb|RSI|
which is the 2nd parameter to the systemcall. The 1st argument (in \verb|RDI|)
to the systemcall is the file descriptor (\verb|1| is stdout). Additionally the
number of the systemcall (\verb|1|) is passed in \verb|RAX|. The systemcall
(\verb|syscall|) now prints \verb|RDX| bytes from \verb|[RSI]| to the file
descriptor \verb|RDI|.

At the end we return to the caller.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the number of bytes to print to \verb|stdout|
\item [RSI] the address to the bytes to print to \verb|stdout|
\end{labeling}

<<nprint>>=
_nprint:
     mov       RDX,RSI
     mov       RSI,RDI
     mov       RDI,1
     mov       RAX,1
     syscall
     ret
@ %def _nprint

\subsection{Printing C-Strings}

The routine [[_print]] prints a null-terminated string to \verb|stdout|.

First we clear the direction flag to increment the address in \verb|RDI| while
scanning the data.

Next we start with clearing \verb|AL| (setting it to null) and saving the
address of the string to \verb|RSI|. We're using \verb|RSI| because we later
need the address to calculate the length of the string.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address to the null-terminated bytes to print to \verb|stdout|
\end{labeling}

<<print>>=
_print:
     cld
     xor       AL,AL
     mov       RSI,RDI
@ %def _print

Next we search for the terminating \verb|null| ('\verb|\0|') character. For this
we use the instruction \verb|scasb| (scan string byte) which compares the byte
at the address \verb|[RDI]| with the value in \verb|AL| and sets the flags
accordingly. When the byte at \verb|[RDI]| is not the value of \verb|AL| the
next instruction (\verb|jne|) jumps to the given label (\verb|.next_char| in
this case).

\verb|scasb| additionally increments \verb|RDI| so that we go through the string
until '\verb|\0|' is found.

<<print>>=
.next_char:
     scasb
     jne       .next_char
@

After we have found the string termination we calculate the number of bytes that
the string has. For this we exchange the registers \verb|RDI| and \verb|RSI|. In
\verb|RDI| we now have the starting address of the bytes to print and in
\verb|RSI| we have the end address of the bytes to print. After that we
calculate the number of bytes to print.

<<print>>=
     xchg      RDI,RSI
     sub       RSI,RDI
@

Now we have the address of the string in \verb|RDI| and the length of the string
in \verb|RSI| which are the 1st and 2nd argument in the call of [[_nprint]].

<<print>>=
     call      _nprint
     ret
@

\section{Printing Numbers}

TBD

\appendix

\printglossary

\printacronyms

\printglossary[type=ins]

\chapter{Code Chunks}

\nowebchunks

@
\end{document}
