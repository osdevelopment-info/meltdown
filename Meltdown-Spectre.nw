\documentclass[paper=a4]{scrbook}

\renewcommand{\rm}[0]{\normalfont \rmfamily}
\renewcommand{\tt}[0]{\normalfont \ttfamily}
\renewcommand{\it}[0]{\normalfont \itshape}

\usepackage{noweb}
\usepackage{xcolor}
\usepackage[breaklinks]{hyperref}
\usepackage[acronym,toc,numberedsection=autolabel,nopostdot]{glossaries}

\renewcommand{\autodot}{}

\hypersetup{
    colorlinks=true,
    linkcolor=[rgb]{0,0,.4},
    urlcolor=[rgb]{.3,0,.4},
    linktoc=all,
    pdftitle={Meltdown and Spectre Samples},
}

\setkomafont{labelinglabel}{\ttfamily}

\newglossary*{ins}{x86-Instructions}

\makeglossaries

\setacronymstyle{long-short}

\newacronym{rng}{RNG}{random number generator}

\newacronym{ascii}{ASCII}{American Standard Code for Information Interchange}

\glsunset{ascii}

\newacronym{cr}{CR}{carriage return}

\newglossaryentry{x86}{
    name=x86,
    description={x86 denotes a microprocessor architecture based on the
    8086/8088}
}

\newglossaryentry{rdtsc}{
    type=ins,
    name=\ttfamily{rdtsc},
    description={Read Time Stamp Counter, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}}
}

\newglossaryentry{lfence}{
    type=ins,
    name=\ttfamily{lfence},
    description={Load Fence, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}~4}
}

\newglossaryentry{clflush}{
    type=ins,
    name=\ttfamily{clflush},
    description={Flush Cache Line, introduced with
        Intel\textsuperscript{\textregistered}
        Pentium\textsuperscript{\textregistered}~4}
}

\begin{document}
@

\author{U. Plonus}
\title{Meltdown and Spectre Samples}
\subtitle{Written in Assembly}
\maketitle

\tableofcontents

\chapter{Introduction}

\section{Overview}

TBD

\section{Nasm}

TBD

<<preamble>>=
bits 64
     global         _start
     pagesize       equ 4096
@ %def pagesize _start

\chapter{Cache Access Timing}

\section{Introduction}

TBD

\section{Detect Cache Access Time}

\subsection{High Resolution Timer}

First we need a high resolution timer to determine the cache access time. For
this we use the time stamp counter. The time stamp counter is monotonically
incrementing. When reading the time stamp counter (with \gls{rdtsc}) the result
is delivered back in the registers \verb|EDX| and \verb|EAX| forming a 64bit
value. The time stamp counter is not an absolute value but a relative value,
meaning that you cannot (easily) calculate from the time stamp counter to some
time units (e.g. ns). But this is no problem as we only want to measure relative
times.

To retrieve a 64bit value for the time we shift the value in \verb|EDX| 32 bits
to the left and add the value of \verb|EAX| to this.

<<tsc-64bit>>=
     rdtsc
     shl       RDX,32
     add       RAX,RDX
@

\subsection{Cache Access Time Routine}

Next we need a routine that calculates the cache access time for us.

First we have to ensure in this routine that the speculative execution of the
processor does not interfere with our time measurement. For this we use the
instruction \gls{lfence} which ensures that all previous reads are done before
executing the next instructions.

Next we access a memory location with the address \verb|RDI| by loading this
into \verb|RCX| and measure the time before and after the access.

The command \gls{lfence} before reading the time stamp counter is needed
because we have to ensure that all reads before the time measurements are done.

At last we calculate the relative time needed to access the memory location. In
theory we should see a difference whether the memory location is accessed before
or not.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address of the memory which is loaded either from the cache or
from memory
\end{labeling}

<<calculate-cache-access-time>>=
_calccachetime:
     lfence
<<tsc-64bit>>
     mov       R8,RAX
     mov       RCX,[RDI]
     lfence
<<tsc-64bit>>
     sub       RAX,R8
     ret
@ %def _calccachetime

\section{Measure Cache Access Time}
\label{sec:Measure Cache Access Time}

\subsection{Setup}

To measure the cache timing we create a standalone program that shows us the
time for a cached and for an uncached memory access.

First we need some area in memory with data which we can later read from. This
data area goes into the area \verb|.bss| which contains uninitialized data. We
align the data at a page boundary and reserve 2 pages for our data.

<<cachetiming-uninitialized-data>>=
     align          pagesize
     data:          times 2 resb pagesize
@ %def data

From time to time we need a small scratch area so we define an area with
32~bytes.

<<scratch-data>>=
     scratch:       resb 32
@ %def scratch

<<cachetiming-uninitialized-data>>=
<<scratch-data>>
@

The program begins with the label \verb|_start| and is in the section
\verb|.text|.

<<cachetiming-program>>=
section .text
_start:
@

Now we start with initialising the [[data]] area with some random data. For this
we load \verb|RDI| with the address of the [[data]] area.

<<cachetiming-program>>=
     mov       RDI,data
@

Next we load the number of bytes to fill into \verb|RSI|. For this we load the
[[pagesize]] into \verb|RSI| and multiply it with $2$ by shifting the value
1~bit to the left.

<<cachetiming-program>>=
     mov       RSI,pagesize
     shl       RSI,1
@

At last we load \verb|EDX| with some random seed. For this we use \gls{rdtsc}
and only use the lower 32~bit of the value.

<<cachetiming-program>>=
     rdtsc
     mov       EDX,EAX
@

Now we call [[_xorshift]] to fill the [[data]] area.

<<cachetiming-program>>=
     call      _xorshift
@

\subsection{Measure Time}

Now that we have setup our [[data]] area we can now cache data from the first
page by loading it into a register which also loads this into the cache.

For this we load \verb|RDI| with the address of the [[data]] area.

<<cachetiming-program>>=
     mov       RDI,data
@

Before we load the data into a register now we will clear the cache lines with
the given address. For this we use the instruction \gls{clflush}. After flushing
the cache line we ensure (with \gls{lfence}) that all reads from memory are
finished before we load the data into a register again (and filling the cache).

<<cachetiming-program>>=
     clflush   [RDI]
     lfence
     mov       RCX,[RDI]
@

Now we can determine the time that is needed to load this data once again. We do
not need to load \verb|RDI| again because it has not changed.

<<cachetiming-program>>=
     call      _calccachetime
@

Now we have the relative cache access time in register \verb|RAX|. We store this
value to the stack and print out an explaining text.

For this we define the text to print and (as a helper) a \gls{cr}.

<<cachetiming-rodata>>=
     scr:           db 0x0a
     scached:       db "Cached Access Time: ",0x00
@ %def scached scr

Now we can print the text.

<<cachetiming-program>>=
     push      RAX
     mov       RDI,scached
     call      _print
@

Then we restore the value and print the measured time to \verb|stdout|. At last
we append a \gls{cr} to the output.

<<cachetiming-program>>=
     pop       RDI
     mov       RSI,scratch
     call      _printdu64bit
     mov       RSI,scr
     mov       RDI,1
     call      _nprint
@

Now we do the same with an uncached value. The difference is that we do not load
the value before.

<<cachetiming-program>>=
     mov       RDI,data
     clflush   [RDI]
     lfence
     call      _calccachetime
@

Now we have the time of the uncached data access in \verb|RAX| and can print it
out with some explaining text.

<<cachetiming-rodata>>=
     suncached:     db "Uncached Access Time: ",0x00
@ %def suncached

<<cachetiming-program>>=
     push      RAX
     mov       RDI,suncached
     call      _print
     pop       RDI
     mov       RSI,scratch
     call      _printdu64bit
     mov       RSI,scr
     mov       RDI,1
     call      _nprint
@

Now we can put everything together and have our \verb|cachetiming| program that
we can now execute.

<<cachetiming.asm>>=
<<preamble>>

section .rodata
<<cachetiming-rodata>>

section .bss
<<cachetiming-uninitialized-data>>

<<cachetiming-program>>

<<exitProgram>>

<<calculate-cache-access-time>>

<<xorshift-prng>>

<<utilities>>
@

The program is placed in \verb|asm/|. With \verb|make| in the folder we can
create an executable which is moved to \verb|bin/|. There we can execute this
program.

\section{Read Array via Cache Access Time}

Now that we have seen that we can determine if a value was in the cache or not
(see \ref{sec:Measure Cache Access Time}
\nameref{sec:Measure Cache Access Time}) we will read a complete array of data
by only measuring the cache access time.

For this we start with some data area that we can read later.

<<cacheread-preamble>>=
     datasize       equ 1024
@

<<cacheread-uninitialized-data>>=
     align          pagesize
     data:          resb datasize
@

Additionally we add a scratch area again.

<<cacheread-uninitialized-data>>=
<<scratch-data>>
@


TBD

<<cacheread-program>>=
section .text
_start:
@

TBD

<<cacheread.asm>>=
<<preamble>>
<<cacheread-preamble>>

section .bss
<<cacheread-uninitialized-data>>

<<cacheread-program>>

<<exitProgram>>

<<calculate-cache-access-time>>

<<xorshift-prng>>

<<utilities>>
@

\chapter{Signals}

\section{Basics}

TBD

\section{Detecting Signals}

TBD

\section{Handling Signals}

TBD

\chapter{Utilities}

\section{Introduction}

TBD

<<utilities>>=

<<nprint>>

<<print>>

<<printdu64bit>>
@

\section{Exit Program}

TBD

<<exitProgram>>=
     xor       RDI,RDI
     mov       RAX,60
     syscall
@

\section{Random Number Generator}

To initialize the data a \gls{rng} is used. The sample programs use
xorshift\footnote{\url{https://en.wikipedia.org/wiki/Xorshift}} as \gls{rng}.

First we clear the direction flag to ensure that we are incrementing the data
pointer \verb|RDI|.

Next we move the number of values to be generated to \verb|RCX| (which is a
counter in \gls{x86} processors) and divide it by 4 (because we use a 32bit
\gls{rng}). Additionally we move the seed to \verb|EAX|.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address of the memory which is to be filled with random numbers
\item [RSI] the number of bytes that are filled with random numbers. This must
be a multiple of $4$
\item [EDX] the seed of the \gls{rng}
\end{labeling}

<<xorshift-prng>>=
_xorshift:
     cld
     mov       RCX,RSI
     shr       RCX,2
     mov       EAX,EDX
@ %def _xorshift

Now we can generate the next 32bit random number.

<<xorshift-prng>>=
.next_random:
     mov       EBX,EAX
     shl       EAX,13
     xor       EAX,EBX
     mov       EBX,EAX
     shr       EAX,17
     xor       EAX,EBX
     mov       EBX,EAX
     shl       EAX,5
     xor       EAX,EBX
@

Because we want to generate multiple random numbers we store the value of
\verb|EAX| to \verb|[RDI]| and loop for the next random number.

<<xorshift-prng>>=
     stosd
     loop      .next_random
     ret
@

\section{Printing Strings}

\subsection{Printing Strings with Length}

The routine [[_nprint]] prints a string with the given length to \verb|stdout|.

We move the number of bytes to print to \verb|RDX| which is the 3rd parameter to
the systemcall. Next we move the address of the bytes to print to \verb|RSI|
which is the 2nd parameter to the systemcall. The 1st argument (in \verb|RDI|)
to the systemcall is the file descriptor (\verb|1| is stdout). Additionally the
number of the systemcall (\verb|1|) is passed in \verb|RAX|. The systemcall
(\verb|syscall|) now prints \verb|RDX| bytes from \verb|[RSI]| to the file
descriptor \verb|RDI|.

At the end we return to the caller.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the number of bytes to print to \verb|stdout|
\item [RSI] the address to the bytes to print to \verb|stdout|
\end{labeling}

<<nprint>>=
_nprint:
     mov       RDX,RDI
     mov       RDI,1
     mov       RAX,1
     syscall
     ret
@ %def _nprint

\subsection{Printing C-Strings}

The routine [[_print]] prints a null-terminated string to \verb|stdout|.

First we clear the direction flag to increment the address in \verb|RDI| while
scanning the data.

Next we start with clearing \verb|AL| (setting it to null) and saving the
address of the string to \verb|RSI|. We're using \verb|RSI| because we later
need the address to calculate the length of the string.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the address to the null-terminated bytes to print to \verb|stdout|
\end{labeling}

<<print>>=
_print:
     cld
     xor       AL,AL
     mov       RSI,RDI
@ %def _print

Next we search for the terminating \verb|null| ('\verb|\0|') character. For this
we use the instruction \verb|scasb| (scan string byte) which compares the byte
at the address \verb|[RDI]| with the value in \verb|AL| and sets the flags
accordingly. When the byte at \verb|[RDI]| is not the value of \verb|AL| the
next instruction (\verb|jne|) jumps to the given label (\verb|.next_char| in
this case).

\verb|scasb| additionally increments \verb|RDI| so that we go through the string
until '\verb|\0|' is found.

<<print>>=
.next_char:
     scasb
     jne       .next_char
@

After we have found the string termination we calculate the number of bytes that
the string has. In \verb|RSI| we now have the starting address of the bytes to
print and in \verb|RDI| we have the end address of the bytes to print.
After that we calculate the number of bytes to print.

<<print>>=
     sub       RDI,RSI
@

Now we have the address of the string in \verb|RDI| and the length of the string
in \verb|RSI| which are the 1st and 2nd argument in the call of [[_nprint]].

<<print>>=
     call      _nprint
     ret
@

\section{Printing Numbers}

\subsection{Printing a 64bit Unsigned Integer}

The routine [[_printdu64bit]] print a given number as unsigned decimal number
with 64bit to \verb|stdout|.

To print a decimal number we have to divide the number by $10$ and get the
remainder for printing (from right to left). For this we move the divisor to
a register and the dividend to \verb|RAX|. We have to use \verb|RAX| because
this is the only register we can use for division.

Additionally we need the address of the scratch area in \verb|RDI| for storing
the result. We also save the address of the scratch area to \verb|R8| for later
use.

To increment the address during the processing we clear the direction flag.

\paragraph{Parameters}
\begin{labeling}{[XXX-XXX]}
\item [RDI] the number number to print to \verb|stdout|
\item [RSI] the address of a scratch area with a size of at least 20 bytes
\end{labeling}

<<printdu64bit>>=
_printdu64bit:
     mov       RAX,RDI
     mov       RDI,RSI
     mov       R8,RDI
     mov       RCX,10
     cld
@ %def _printdu64bit

Now we define a label to jump back when we see that there are still more digits
to print. Then we test \verb|RAX| for $0$ and end the processing of the digits.

<<printdu64bit>>=
.next:
     cmp       RAX,0
     je        .done
@

Next we divide \verb|RAX| by \verb|RCX|. For this we have to clear \verb|RDX|
because this is the higher value of the dividend. The result is then placed into
\verb|RAX| and the remainder into \verb|RDX|.

<<printdu64bit>>=
     xor       RDX,RDX
     div       RCX
@

We now exchange the result and the remainder because we now need the remainder
in \verb|RAX| (or \verb|AL|) for further processing. Now we can add the
\gls{ascii} character '0' to AL and have the correct \gls{ascii} value in AL.
Now we can store the \gls{ascii} character to the scratch area.

<<printdu64bit>>=
     xchg      RDX,RAX
     add       AL,'0'
     stosb
@

Now we restore \verb|RAX| (which we saved to \verb|RDX|) to go into the next
round.

<<printdu64bit>>=
     mov       RAX,RDX
     jmp       .next
@

Now that we have all the numbers as \gls{ascii} characters we are nearly done.
We now have to reverse the number in memory because the number saved at the
lowest address is the digit with the least significance.

We now start with checking if we have written any character. If not then we
write the \gls{ascii} character '0' into the memory. We use the instruction
\verb|stosb| for this to adjust the address in \verb|RDI| at the same time.

<<printdu64bit>>=
.done:
     cmp       RDI,RSI
     jne       .printout
     mov       AL,'0'
     stosb
.printout:
@

Next we calculate the number of digits that the number has. For this we move the
address of the last digit to \verb|RDX| and subtract the start of the scratch
area from this. Next we adjust \verb|RDI| because it points to the first address
after the number.

<<printdu64bit>>=
     mov       RDX,RDI
     sub       RDX,RSI
     dec       RDI
@

We now have \verb|RSI| with the address of the start of the number and
\verb|RDI| with the address of the end. We now have to exchange the digits from
the front and the end to get the right number. For this we increment \verb|RSI|
and decrement \verb|RDI| after each exchange and when the addresses pass each
other we are done.

<<printdu64bit>>=
.reverse:
     mov       AL,[RSI]
     mov       AH,[RDI]
     mov       [RSI],AH
     mov       [RDI],AL
     dec       RDI
     inc       RSI
     cmp       RSI,RDI
     jb        .reverse
@

Now we restore the address of the scratch area to \verb|RSI| and move the number
of digits (which we stored in \verb|RDX|) to \verb|RDI| and can the call
[[_nprint]] to print the number.

<<printdu64bit>>=
     mov       RSI,R8
     mov       RDI,RDX
     call      _nprint
     ret
@

\appendix

\printglossary

\printacronyms

\printglossary[type=ins]

\chapter{Code Chunks}

\nowebchunks

@
\end{document}
